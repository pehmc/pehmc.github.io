---
title: "编程语言：务实之道（Part 1/3）"
excerpt: '从小工到大家'

collection: theory
category: basic
permalink: /theory/basic/code-pragm
tags: 
  - idea

layout: single
read_time: true
author_profile: false
comments: true
share: true
related: true
---

![](../../images/theory/basic/code/pragmatic.png)

## 哲学

### 1. 我的源码被猫吃了[^1]

不要把所有问题都归咎于供应商、编程语言、管理或是同事。这些因素都可能是问题的一部分。它们的确会对解决方案造成影响，但不是给你的借口。

如果你面临供应商帮不上忙这样的风险，就应该制订一个应急方案。如果磁盘挂起——你所有的源码都在里面——而你没有备份，这就是你的错。跟你的老板说“我的源码被猫吃了”解决不了问题。

### 2. 不要放任破窗

不要搁置“破窗”（糟糕的设计、错误的决定、低劣的代码）不去修理。每发现一个就赶紧修一个。如果没有足够的时间完全修好，那么就把它钉起来。也许你可以注释掉那些糟糕的代码，显示一行“尚未实现”的信息，或用假数据先替代一下。

不要只是因为一些东西非常危急，就去造成附带损害。破窗一扇都嫌太多。

### 3. 石头做的汤和煮熟的青蛙

先拿出石头开始做汤，有了更多需求再加点胡萝卜、土豆，先开始再不断完善。

不要学寓言里的青蛙，永远留意着大局，持续不断地审视总体发生的事情，而不要只专注于你当前在做的事情。

### 4. 交流

作为开发人员，我们必须在多个层次上进行交流。

我们会花数个小时开会，倾听和交谈。我们会和最终用户一起合作，去理解他们的需求。我们编写代码，代码将我们的意图传达给机器；我们编写文档，文档为下一代开发者记录了我们的想法。我们写建议和备忘录，用于解释资源申请、报告现状及提出新的方案。

把英语（或者你的母语是别的什么语言）看成另一门编程语言。像写代码一样用自然语言写文章：尊重DRY原则、ETC、自动化。

务实的程序员将文档视为整个开发过程的一个组成部分。为了让编写文档变得更容易一点，我们要避免重复劳动和浪费时间，让文档总是在手边——直接写在代码里。用源码中的注释生成好看的文档非常容易，建议给模块和导出函数都加上注释，这能在其他开发者使用的时候，给他们很大的助力。

不过，有人说必须给每个函数、数据结构、类型声明等都分别加上注释，我们并不赞同这种做法。这种机械的注释方式实际上会导致代码更难维护：一旦你想改点什么，就需要改变两个东西。因此，将非API的注释限制在只用来讨论其为何存在及其意图、目标。当代码已经展示了事情怎样完成时，注释是多余的——因为这违反了DRY原则。

注释源码是一个绝佳的机会，可以用来记录那些在其他地方无法记录的项目细节：工程上的权衡，为什么要做决定，放弃了哪些替代方案，等等。

## 方法

### 1. ETC原则

（Easier To Change，更容易变更）

为什么解耦很好？因为通过隔离关注焦点，可让每一部分都容易变更——此谓ETC。

为什么单一职责原则很有用？因为一个需求变化仅体现为某个单一模块上的一个对应变化——此谓ETC。

为什么命名很重要？因为好的命名可以使代码更容易阅读，而你需要通过阅读来变更代码——此谓ETC！

### 2. DRY原则

（Don’t Repeat Yourself,不要重复自己）

当代码的某个单一方面必须改变时，你是否发现自己在多个地方以多种不同的格式进行了变更？有没有同时修改代码和文档，或是同时变更数据库Schema和代码中相关的数据结构，亦或……？如果这类情况发生，你的代码并不满足DRY。

下面让我们来看看一些典型的关于重复的例子。
- 代码中的重复，修改代码时需要修改多个地方，不符合DRY
- 文档中的重复，多次修改后，注释和代码就会变得不同步，不符合DRY
- 数据中的重复，一条线段有起点和终点，而且一定有长度（即使长度为零）。不过这里出现了重复。长度是由起点及终点定义出来的：改变一个端点必然引起长度的变化。最好是把长度定义为一个通过计算得到的字段
- 表征的重复
    - 内部API间的重复，对于内部API，去找个工具，用来将API描述成一种中立的格式。这些工具通常能生成文档、模拟API、功能测试。之后还可以生成不同语言的API客户端。理想情况下，这个工具会把API保存在一个中心仓库中，以便不同的团队共享。
    - 外部 API 间的重复，你会发现，公开的API越来越多采用类似OpenAPI的东西来做正式的规范。这可以方便你将API规范导入你的本地API工具，更可靠地和服务集成。如果找不到这样的规范，可以考虑自己创建一个并发布。不只是别人会觉得它有用，甚至你在维护它时也能获得帮助。
    - 数据源引起的重复，不用专门编写代码来定义固定结构的外部数据（例如具体的struct 或class），只要把数据插入键值对的数据结构（在你用的语言中，这种结构可能叫表、哈希表或字典，甚至就叫对象）中即可。

### 3. 正交性原则

在计算科学中，这个术语象征着独立性或解耦性。对于两个或多个事物，其中一个的改变不影响其他任何一个，则这些事物是正交的。

大多数开发人员对设计正交系统的必要性都很熟悉。只不过他们可能会使用其他一些词来描述这个过程，例如模块化、基于组件和分层。
- 系统应该由一组相互协作的模块构成，每个模块实现的功能应独立于其他模块。
- 有时这些模块组件被组织到不同的层次上，每一层都做了一级抽象。这种分层的实现是设计正交系统的有力途径。因为每一层只使用它下面一层提供的抽象

可以用一个简单的方法来测试设计的正交性。当你规划好组件后，问问自己：如一个特别功能背后的需求发生显著改变，有多少模块会受影响？对于一个正交系统，答案应该是“一个”

有几种技术可以用来保持正交性：
- 保持代码解耦，编写害羞的代码——模块不会向其他模块透露任何不必要的信息，也不依赖于其他模块的实现。
- 避免全局数据，。一般来说，如果总是显式地将任何需要的上下文传递给模块，那么代码会更容易理解和维护。
- 避免相似的函数，我们经常会遇到一组看起来很相似的函数——或许在开头和结尾的地方共享了公共代码，但是每个函数都有不同的中心算法。想要更好的实现，可以看看《设计模式》中的策略模式。
- 重构，养成不断质疑代码的习惯。只要有机会就重新组织、改善其结构和正交性。
- 测试，编写单元测试本身就是一个有趣的正交性测试。做什么才能让单元测试构建出来并运行起来？需要导入系统其余的大部分代码吗？如果是这样，那么就已经发现了一个与系统其余部分没有很好地解耦的模块。

使用DRY时，你追求最小化系统中的重复。反之，在使用正交时，则要去减少系统组件之间的相互依赖。

### 4. 可逆性原则

只要坚持推荐的做法，尤其是解耦，以及外部配置这些原则，我们就不必做太多不可逆转的关键决定。

错误在于认为任何决定都是板上钉钉的——而没有为可能出现的意外做好准备。与其认为决定是被刻在石头上的，还不如把它们想象成写在海滩的沙子上。一个大浪随时都可能袭来，卷走一切。

为未来编写代码会很困难。但是，可以把代码的演化路线想象成装满了薛定谔猫的盒子：每一个决定都会导致不同版本的未来。你的代码可以支持多少种可能的未来？

### 5. 曳光弹原则

曳光弹之所以有用，是因为其工作环境和约束与真实子弹的相同。曳光弹能快速抵达目标，所以枪手可以得到即时的反馈。
曳光代码不是一次性的：编写它是为了持续使用。
- 构造了一个可以在其中工作的框架，如果已经打通了应用程序的所有层面，并将它们通过代码表达出来，那么团队就不需要太多无中生有的东西。
- 有了一个集成平台，当系统已经打通时，你就有了一个环境，可以在做完单元测试后立刻把代码一块块加进来。你可以每天（通常是一天多次）持续集成，而不必去面对一个巨量的集成工作。
- 有可以演示的东西，项目赞助商和公司高层倾向于在最不适当的时候想起看看演示。只要使用曳光代码，你总是有东西可以演示。

曳光代码虽然简单但是完整，它是最终系统框架的组成部分。

### 6. 领域语言原则

编写解析器可能意味着要向你的程序添加新的库和工具。编写一个好的解析器并不是一件简单的工作。但是，如果你有一颗坚强的心，可以试试bison或ANTLR之类的解析器生成器，或是诸如PEG之类的解析框架。

我们的建议相当简单：花费的努力不要比节省下来的还多。编写领域语言会给项目增加一些成本，所以你需要确信省下的花销（在可预计的长期）足以抵消它。

## 工具

### 1. 版本控制

即使你只有一个人且项目一周就会结束，即使它是一个“用完即弃的”原型，即使你操作的不是源码，永远都应如此。确保所有内容都在版本控制之下。

### 2. 调试

调试心理学：
- 去解决问题，而不是责备。Bug 是你的错还是别人的错并不重要。无论是谁的错，问题仍然要你来面对。
- 不要恐慌。人们很容易陷入恐慌，尤其是当最后期限逼近，或是在老板或客户站在背后紧张凝视之下，拼命找出问题原因的时候。然而，这时非常重要的是要退后一步冷静思考。不要在“但那不可能发生”的思路上浪费哪怕一个神经元，因为很明显它会发生，而且已经发生了。

调试时要注意不要短视，。永远要去发掘问题的根本原因，而不仅仅停留在问题的表面现象。
- 复现 Bug，毕竟，如果你不能重现它，又怎么知道它究竟是否被修复了呢？
- 读一下那些该死的出错信息，输出日志及（或）跟踪信息。
- 找个橡皮鸭，在向另一个人解释这个问题时，你必须明确地陈述自己检查代码时可能认为理所当然的事情。通过把这些假设用语言表达出来，你可能会突然对这个问题有了新的认识。
- 排除法，操作系统、编译器或第三方产品中都可能存在 Bug，但这不是首先要考虑的。

### 3. 工程日记

日记本有三大好处。
- 它比记忆更可靠
- 它为你提供了一个地方，用来保存与当前任务无关的想法
- 它就像一种橡皮鸭，当你停下来，把东西写上去的时候，大脑可能会换档，几乎就像在和某人说话一样
- 你能时不时地回想起多年以前你在做什么，会想到那些人、那些项目

## 经验

### 1. 契约式编程

在编写代码之前，简单地列出输入域的范围、边界条件是什么、例程承诺要交付什么。

对于不支持在代码中契约的语言，也可以将契约作为注释加入代码或是写入单元测试。

### 2. 断言式编程

预防不可能的事情。

不要使用断言来代替真正的错误处理。断言检查的是不可能发生的事情。

而且，不能仅仅因为大多数 assert的实现在断言失败时将终止进程，就认为你写的这个版本也应当如此。如果需要释放资源，请捕获断言抛出的异常或捕获退出，然后运行自己的错误处理程序。

### 3. 保持资源的平衡

无论在什么时候，我们写代码都要管理资源：内存、事务、线程、网络连接、文件、计时器——所有可用的数量有限的东西。

### 4. 响应式程序

响应式应用程序用来处理事件：可能来自外部世界，或者来自内部。

看看能帮助我们的四个策略：
- 有限状态机
- 观察者模式
- 发布/订阅
- 流

### 5. 变换式编程

编程讲的是代码，而程序谈的是数据。

在变换式模型中，我们将其颠倒过来。不要把数据看作是遍布整个系统的小数据池，而要把数据看作是一条浩浩荡荡的河流。数据成为与功能对等的东西：管道是一系列的代码→数据→代码→数据……数据不再和特定的函数组一起绑定在类定义中。

### 6. 继承税

让我们推荐三种技术，它们意味着你永远不需要再使用继承：
- 接口与协议，给了我们一种不使用继承的多态性
- 委托，用委托提供服务，“有一个”胜过“是一个”
- mixin 与特征，基本思想是能够为类和对象扩展新的功能，但不用继承

### 7. 配置

如果代码依赖某些值，而这些值在应用程序发布后还有可能改变，那么就把这些值放在程序外部。

配置的两种方案：
- 静态配置，目前，YAML和 JSON非常流行，有时，有些用脚本语言编写的应用程序会分出几个源码文件，专门用来包含配置数据。
- 配置服务化，我们仍然希望配置数据保持在应用程序外部，但不直接放在文件中，也不放在数据库里；而是储存在一个服务 API之后

### 8. 一切都会并发

通过分析工作流来提高并发性。

共享状态是不正确的状态。

随机故障通常是并发问题。

[^1]: The Pragmatic Programmer https://pragprog.com/titles/tpp20/the-pragmatic-programmer-20th-anniversary-edition/