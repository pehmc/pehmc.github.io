---
title: "漏洞：分类（Part 1/4）"
excerpt: '漏洞类型 Top K'

collection: theory
category: sec
permalink: /theory/sec/vuln-class
tags: 
  - vuln

layout: single
read_time: true
author_profile: false
comments: true
share: true
related: true
---

![](../../images/theory/sec/vuln_class/vuln.png)

## 概述

未验证、未正常处理的输入或者操作可能引发漏洞，各种类型的漏洞可能相互引发，形成一条漏洞链，共同造成代码执行等影响。

### 一、漏洞的影响

根据漏洞对程序的影响分类，漏洞的影响有以下4种[^1]：
1. DoS/抛出异常
2. 信息泄露
3. 权限提升
4. 代码执行

### 二、漏洞的分类

漏洞存在2类：
- 代码漏洞，不同的编程语言受到不同漏洞的影响,主要的语言：Python，C++，Go，Java。
- 逻辑漏洞，在更高的维度存在的漏洞。

## Top K 代码漏洞

涵盖最常见的代码漏洞[^2]。

### 一、OOB（Out-of-bounds）

OOB类型的漏洞有两种原语：
1. OOB R，越界读，导致泄漏关键信息绕过保护策略、读取到非预期的内存页。
2. OOB W，越界写，导致关键指针、数据和控制结构被覆盖，同时越界写通常可以实现越界读。

#### 1.栈溢出（OOB R/W）
> **受影响的语言：Python，C++，Go，Java**

栈溢出是一种 OOB R/W 漏洞，通过构造恶意输入可导致4种影响：
1. 抛出异常，仅内存安全语言。
2. 信息泄露，复用程序代码来泄露信息。
3. 权限提升，利用内核栈溢出提升进程权限。
4. 代码执行，通过覆写rip或者修改栈上的函数指针实现。

当栈溢出发生时，有以下2种情况：
1. 溢出空间可控，在用户态程序或内核调用strcpy(), gets(), sprintf()等不检查是否越界的函数时出现。
- 常见的漏洞利用：通过栈迁移布置ROP链实现代码执行，kROP实现提权。
2. off-by-one，在用户态程序或内核调用strncat(), strncpy(),strlen()时出现。
- 常见的漏洞利用：覆写rip，rbp或者邻接变量实现控制流劫持。

#### 2.堆溢出（OOB R/W）
> **受影响的语言：Python，C++，Go，Java**

堆溢出是一种OOB R/W漏洞，通过构造恶意输入可导致4种影响：
1. 抛出异常，仅内存安全语言。
2. 信息泄露，通过堆重叠泄露信息。
3. 权限提升，利用内核堆溢出提升进程权限。
4. 代码执行，覆写堆结构相关信息达到代码执行。

用户态程序的堆溢出发生在用户态堆管理器中，比如ptmaloc2，而内核堆溢出则发生在特定内核的堆管理器中，比如Linux内核的slub。当堆溢出发生时，有以下2种情况：
1. 溢出空间可控，堆溢出类似于栈溢出，都是由于写入的数据没有控制好大小导致的。区别是堆上并不存在返回地址等数据，但是存在堆结构相关信息。
- 常见的漏洞利用：通过覆写后续的used、freed堆块，对于used篡改它的函数指针达到代码执行。或者对于freed通过tcache污染、各种bins篡改达到任意地址读写，在此基础上覆写got表，篡改FSOP、rtld_global上面的函数指针为one_gadget，实现代码执行。
2. off-by-one，类似于栈off-by-one，区别在于堆off-by-one造成代码执行的可利用性与堆溢出相当。
- 常见的漏洞利用：一个例子是用户态程序溢出0x00时，在size为0x100倍数的时，使得prev_in_use位被清，这样前块会被认为是freed块，从而触发特定bin的前向合并造成unsafe unlink，实现任意地址写，在此基础上覆写got表，篡改FSOP、rtld_global上面的函数指针为one_gadget，实现代码执行。

#### 3.缺陷函数越界访问（OOB R）
> **受影响的语言：Python，C++，Go，Java**

缺陷函数越界访问是OOB R类型漏洞，造成2种影响：
1. 抛出异常，仅内存安全语言。
2. 信息泄露，越界访问会造成泄漏，导致栈地址、堆基址、libc和ld基址被泄露。常见的类string返回时，其实是把栈地址addr作为参数，传入函数使其把返回的string类存储在addr指向的栈空间当中。据此可以泄漏栈基址。

### 二、UAF（Use-After-Free）

UAF类型的漏洞有4种原语：
1. UAF W，释放后写，导致关键指针、数据和控制结构被篡改。
2. UAF R，释放后读，导致泄漏关键信息绕过保护策略。
3. Double Free，二次释放，达到UAF R/W的效果。
4. UAF变种。

#### 1.堆UAF（UAF R/W）
> **受影响的语言：C++**

堆UAF造成的影响：
1. UAF R造成信息泄露，单链表的bins会泄露next chunk地址，利用tcache解密safe link，可以泄露堆基址，右移12位。双链表bins会泄露nextchunk和prechunk地址，可能泄露libc地址。
2. UAF W造成代码执行，使用tcache污染或largebin攻击伪造freelist的指向。再次malloc得到任意地址写。在此基础上覆写got表，篡改FSOP、rtld_global上面的函数指针为one_gadget，实现代码执行。

用户堆UAF：
当一个内存块被free之后再次被使用。此时会出现以下几种情况：
1. 内存块释放后，对应指针设置NULL，造成空指针解引用。
2. 内存块释放后，对应指针非NULL，再次读造成信息泄露、再次写freed chunk元数据造成任意读写。

内核堆UAF：
在内核页管理代码、细粒度的object管理代码中存在UAF漏洞。

#### 2.堆Double Free（UAF R/W）
> **受影响的语言：C++**

当一个内存块被2次free后，再1次allocate时，该块会同时处于allocated和freed状态，即该内存块在保存freed状态bins信息的情况下，是可读写的，由此达到UAF R和UAF W的效果。

堆Double Free达到UAF R和UAF W的效果，造成相同的影响。

#### 3.UAF变种
> **受影响的语言：Python，C++，Go，Java**

即使使用垃圾回收运行时库，也可能出现UAF漏洞，因为UAF的对象除了chunk，还有文件描述符、网络连接等，比如Use After Close，文件描述符关闭之后仍然访问；Double Close，二次关闭文件描述符。

UAF变种造成的影响：
1. 抛出异常，仅内存安全语言。
2. 信息泄漏。
3. 代码执行。

### 三、未初始化
> **受影响的语言：C++**

一些提供给程序访问的变量，比如指针、数值等，可能存在未初始化的问题，未初始化有两种类型：
1. 该变量未赋值，攻击者可以控制该变量的值，进而间接控制程序的行为。
2. 该变量未清除，攻击者可以泄露该变量的值，或者利用过时的值。

未初始化的影响：
1. 信息泄漏
2. 代码执行

### 四、空指针解引用
> **受影响的语言：C++，Go，Java**

空指针解引用发生在程序解引用一个它认为有效的指针时，但它实际上是NULL。空指针解引用问题可能由于许多漏洞而触发，包括竞争条件和简单的逻辑错误。

空指针解引用的影响：
1. 抛出异常，仅内存安全语言。

### 五、整数类型漏洞
> **受影响的语言：Python，C++，Go，Java**

整数类型的漏洞，可能由整数运算、符号转换产生。

#### 1.整数运算

整数溢出是CPU中ALU对(有/无符号)整数之间的运算导致的上溢或下溢。如果一个对象的大小发生整数溢出，会间接影响到栈或堆为该对象分配的空间大小，引发栈溢出和堆溢出，为漏洞利用创造条件。

**1.1 整数上溢**

在OpenSSL 3.3代码中，存在整数上溢。
``` c
int nresp = packet_get_int();

if(nresp > 0){
    response = xmalloc(nresp*sizeof(char*));
    for(int i = 0; i< nresp; i++)
        response[i] = packet_get_string(NULL);
}
```
如果nresp等于UINT_MAX/sizeof(char*)，那么nresp会上溢为0，xmalloc() 分配的堆空间为0，下一行代码的执行会触发堆溢出漏洞。

**1.2 整数下溢**

下面的代码存在整数下溢。
``` c
int num = get_int();
num --;

if(num <= 0) return;
read_buffer(num);
```

如果num等于INT_MIN，符号位作参与运算，会产生下溢，导致其值变成INT_MAX，触发栈越界读。

#### 2.符号转换

在无符号整数、带符号整数之间转换时发生了预期之外的数值误差，误差引发栈溢出和堆溢出，为漏洞利用创造条件。

下面的代码存在符号转换误差。
``` c
char buf[512];
int len = get_src_len();
if(len < 512){
    memcpy(buf,src,len);
}
```
get_src_len()接收无符号数大于231，经过符号转换后len变成负数，绕过if判断，造成栈溢出。

### 3.取反INT_MIN

所有有符号整数类型（int8_t, int16_t, int32_t, int64_t等）的 INTn_MIN 取负都会得到自身。 这是二进制补码表示法的固有特性，源于正负数表示范围的不对称性。

### 六、异常未捕获
> **受影响的语言：Python，C++，Go，Java**

抛出了异常却未被捕获，会执行非预期的控制流。

### 七、反序列化
> **受影响的语言：Python，C++，Go，Java**

在没有验证输入有效的情况下，反序列化了不受信任的数据。攻击者通过构造恶意序列化数据，在反序列化（将数据恢复为对象）时触发非预期行为。

某些编程语言或库在反序列化时会自动执行特定方法（如Java的readObject()、Python的__reduce__），攻击者可利用这些特性注入恶意逻辑。

反序列化的影响：
1. 代码执行。

### 八、非法注入
> **受影响的语言：Python**

非法注入是对命令注入、代码注入和数据库注入的概括。利用命令注入和参数注入构造的语义化输入，可以直接劫持控制流，导致代码执行，利用数据库注入可以泄露信息，或者间接执行代码。

#### 1.命令注入

程序将恶意输入拼接到操作系统命令中，导致代码执行。

#### 2.参数注入

- 参数注入，cgi.exe -s

#### 3.数据库注入

SQL注入和NoSQL注入。

### 九、文件操作
> **受影响的语言：Python**

1.文件读取
2.文件上传
3.路径穿越

### 十、类型混淆

常见于chrome V8 JS的处理

## Top K 逻辑漏洞

涵盖常见的逻辑漏洞。

### 一、越权

访问控制缺失、错误

### 二、硬编码

不安全的凭证

### 三、依赖攻击

依赖于底层代码库

### 四、资源耗尽

Call Stack Overflow（例如 Complex Nested Message）
Flooding the server

### 五、差异化

https://blog.trailofbits.com/2025/06/17/unexpected-security-footguns-in-gos-parsers/

### 六、配置错误

### 七、竞态条件
> **受影响的语言：Python，C++，Go，Java**

竞态条件的影响：
1. 抛出异常
2. 信息泄漏
3. 代码执行

竞态条件（race condition）是指这样一种情形——多个线程或进程在读写一个共享数据时结果依赖于它们执行的相对时间。如果竞态条件危害了程序正确性，就会产生竞态条件漏洞，可以被TSAN明确分类。

#### 1.数据竞争
   
定义内存访问操作：e 为一个四元组 (m,t,L,a) ，其中：m 为内存访问操作的内存地址；t 为标识内存访 问操作的线程；L 为操作所属线程拥有的锁集合；a 为 内存访问操作的类型（READ或WRITE）。
数据竞争 IsRace(ei ,ej) 是满足以下条件的两个内存访问操作：
1. 内存访问位置相同，mi=mj；
2. 两者并发执行；
3. 至少有一个为写操作；
4. 未使用“互斥”的同步机制约束。

DirtyCow 漏洞（CVE-2016-5195）是最为典型的数据竞争引发的漏洞。如下图所示，正常的程序流程三次调用了 faultin_ page 函数完成了三个步骤，其中第二次进入 faultin_ page主要是处理写权限的页错误问题，要求的写权限标 志会被去掉，即去掉FOLL_WRITE标志位，第三次调用 faultin_page 时已经成功得到 cow 后的页面，且 flags 已经去掉 FOLL_WRITE，因此不会再产生写错误的处理， 可以直接写入 cow 的页。

![](../../images/theory/sec/vuln_class/dirtycow.png)

但是如果在上述流程即第二 次页错误处理结束时，在一个新的线程调用madvise，会 unmap 掉前面 cow 的页面，又进入缺页处理，这里不同 的是在do_fault调用时，由于没有了写权限的要求，直接 调用了 do_read_fault读取映射文件的内存页，而不是内存页副本，后续即可实现越权写操作。
在 DirtyCow 漏洞中，两个线程竞争的资源是内存页，并且造成了程序 正确性的影响。某些数据竞争发生时 并不会影响程序的正确性，例如当两个进程竞争的内存 共享资源和两个进程的逻辑完全无关，则认为构成数据竞争但是不构成竞态漏洞。DirtyCow正是由于在数据竞争发生之后导致 任意文件被恶意篡改的危害性结果，才被研究人员归结为竞态漏洞。

#### 2.TOCTTOU

TOCTTOU（Time Of Check To Time Of Use）指计算机系统中的 资源与权限等状态在检查（安全授权）和使用这个检查 结果之间，因为检查结果（如授权状态）在这段时间发 生了改变而造成的漏洞产生。
TOCTTOU 通常发生 在文件系统的访问时，特别是在 UNIX操作系统中较为 常见，文件系统访问一般会要求对文件先检查再写入， 这就导致检查与读写操作之间存在时间间隔，攻击者 可利用这种时间间隔对文件系统展开攻击。
类 Unix 文件系统中存在 TOCTTOU 缺陷的根本原因在于文件 名和文件对象之间的映射是可变的，如下图所示，TOUCTTOU 的典型例子 Binmail。 Binmail是一个setuid-to-root程序，在普通用户权限下可 以调用执行 root 用户权限的操作。在正常的读取邮件 的过场中，Binmail 首先通过 lstat 函数查看文件 mail 的 信息，如果 mail文件是正常文件，不是符号链接则执行 open函数打开邮件。

![](../../images/theory/sec/vuln_class/tocttou.png)

但是由于 lstat和 open函数不是原始操作，所以如果在 lstat函数检查完毕后，另外一个线 程或者进程可以通过 unlink和 symlink操作将 mail文件 替换为指向系统关键文件/etc/passwd等文件的链接，那 么 open 的文件将会是替换后的系统关键文件，实现了任意文件读取。
一个基于文件的TOCTTOU例子的exp如下图所示。use在check后面执行而导致的漏洞。

![](../../images/theory/sec/vuln_class/tocttou_exp.png)

综上，TOCTTOU是竞态漏洞的子集，数据竞争和竞态漏洞存在交集。

#### 3.Double Fetch

Double Fetch也是竞态漏洞的一个子集，该漏洞的原理是：内核从用户空间中拷贝复杂数据时，数据在内核中有两次被取用，内核第一次取用数据进行安全检查（如缓冲区大小、指针可用性等），当检查通过后内核第二次取用数据进行实际处理。

![](../../images/theory/sec/vuln_class/double_fetch.png)

在两次取用的时间间隔里，可以对已通过检查的用户态数据进行篡改，在第二次取用时造成访问越界或缓冲区溢出，最终导致内核崩溃或权限提升。Double Fetch通常会出现在以下场景：

1. 类型选择，第一次取数据识别它的类型，然后对数据篡改，第二次取数据进行相应类型处理时产生混淆。
2. 长度检查，第一次取数据计算它的长度，然后对数据篡改，第二次取数据处理时导致溢出、或者信息泄露。
3. 浅拷贝，第一次取数据只是将指向用户数据的指针拷贝到内核中，然后对指针篡改，第二次取的数据将不是原来通过检查的数据。

从原理上来看，Double Fetch和TOCTTOU类似，都是利用时间间隔篡改数据，造成不一致性。也因此是可以被修复的。

### 八、断言错误

程序为了检测逻辑错误，设置了断言。

[^1]: Vulnerabilities by impact types https://www.cvedetails.com/vulnerabilities-by-types.php
[^2]: CWE Website https://cwe.mitre.org/
