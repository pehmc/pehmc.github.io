---
title: "动态漏洞挖掘：八股文 （Part 4/4）"
excerpt: '模糊测试的八股文'

collection: theory
category: sec
permalink: /theory/sec/fuzz-8gu
tags: 
  - fuzz

layout: single
read_time: true
author_profile: false
comments: true
share: true
related: true
---

![](../../images/theory/8gu.png)

## 任职要求

### 一、模糊测试

- 熟悉模糊测试原理与实现
- 掌握主流模糊测试引擎的使用和实现

## 八股文

### 一、模糊测试原理

**1.QEMU模式、源码模式的区别?**

对比一下qemu模式fuzz和源码模式fuzz，说说qemu模式的动态插桩怎么实现的，有什么优缺点?

**2.普通程序、RobotAgent模糊测试的区别?**

fuzz普通程序和RobotAgent有哪些不同点?
怎么给AFL做适配去fuzz RobotAgent?

**3.AFL++、AFL的区别?**

看你的博客有用过afl++去挖漏洞，说说afl++和afl有哪些不同?你觉得afl++有哪些策略对你来说很有用?

**4.AFL组成模块的工作流程?**

有哪些模块，每个模块的流程? afl-fuzz为什么速度很快?
从选取目标开始插桩

**5.AFL的插桩原理?**

**6.如何选择模糊测试的测试点?**

感觉类似于fuzz单个API函数吧

### 二、场景题：针对一个开源的 RobotAgent 项目，如何动态挖掘?

**1.如何规定挖掘漏洞的范围?**

规定挖掘RobotAgent漏洞的类型：
- 崩溃，传统的程序崩溃（段错误、异常退出）。
- 逻辑错误，决策不合理、任务无法完成、陷入死循环、违反安全策略（如撞墙、自伤）。
- 安全问题，被恶意输入“劫持”，执行非预期指令。

规定挖掘RobotAgent漏洞的范围，核心模块：
- A2A等通信层
- MCP工具调用层
- 针对感知模块的动态测试
- 针对决策与规划模块的动态测试

**追问1：如何保证你的测试覆盖了RobotAgent的核心攻击面?**

**追问2：与标准的AFL++相比，你的改进策略带来了多少效率提升?你是如何量化评估这个效果的?**

- 代码覆盖率。
- 语法正确、语义正确的测试用例数量。

**2.如何构建测试环境，为什么?**

仿真环境搭建： 使用 Gazebo、CoppeliaSim 或项目推荐的仿真器。绝不在真实机器人上首轮测试。仿真器可以：

- 安全地注入故障： 模拟传感器噪声、数据丢失、延迟。
- 场景复现： 精确复现导致崩溃的场景。
- 自动化： 与测试脚本集成，批量运行。

监控与数据记录:
- 监控是否有漏洞
- 记录测试用例，记录测试状态

**3.如何实现的覆盖率统计?**

- 对服务端代码进行插桩，插入的代码会将执行到的边信息写入一块共享内存。

**追问1：共享内存机制是如何搭建起来的?如何解决跨进程、跨环境的通信问题?**

- 被插桩的中间件进程在启动时，会分配一块共享内存，覆盖率数据直接写入其中。外部的Fuzzer进程则直接读取这块共享内存来获取反馈，指导下一轮的变异。

**追问2：引导Fuzzer的覆盖率反馈是边缘覆盖率（edge coverage）还是块覆盖率（block coverage）?你如何看待这两种方式的优劣?**

- 边缘覆盖率（Edge Coverage），它记录了代码块之间的转移关系，比单纯的块覆盖率（Block Coverage）包含了更多的上下文信息，对Fuzzer的引导效果更好。

**4.工具目前支持xxx，如果现在需要你快速接入一种新的RobotAgent，例如xxx，工具架构需要做哪些调整?如何设计以最小化适配成本?**

- 模糊测试：插桩、编写客户端代码（执行、收集依赖关系、启动、关闭）。

**5.如何为xxx，“缓冲区溢出”、“整型溢出”这类漏洞设计初始测试用例?说明构造Payload的思路?**

- 缓冲区溢出：核心是突破长度限制。例如，构造一个远超proto-max-bulk-len配置值的超长字符串作为SET命令的值；或者构造一个包含海量元素的数组请求。
- 整型溢出：核心是触发数值回绕。例如，传入一个-1或0xFFFFFFFF作为大小或长度参数，使其在后续的计算中（如malloc(size * sizeof(char))）发生溢出，导致分配过小的缓冲区。

**6.在测试过程中，如何避免Fuzzer导致程序崩溃后无法继续测试?你的工具是否实现了自动崩溃分类、去重和恢复的机制?**

- 自动恢复：Fuzzer监控进程会检测目标中间件是否崩溃。一旦崩溃，监控进程会立即重启中间件服务，确保Fuzzing过程能持续进行。
- 自动去重：基于ASAN，给出漏洞在源码/二进制码中的位置，基于此`位置哈希`去重。
- 自动分类：基于ASAN，初步分类为heap-buffer-overflow、stack-overflow、integer-overflow等类型。

**7.当Fuzzer发现一个复杂的崩溃时，你通常使用什么工具链和方法来分析根本原因?请描述你的调试流程。**

- 查看ASAN的崩溃报告。
- 定位到代码位置上，对照触发崩溃的测试用例，分析根本原因。